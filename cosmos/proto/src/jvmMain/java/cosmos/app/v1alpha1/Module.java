// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cosmos/app/v1alpha1/module.proto

package cosmos.app.v1alpha1;

public final class Module {
  private Module() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
    registry.add(cosmos.app.v1alpha1.Module.module);
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface ModuleDescriptorOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cosmos.app.v1alpha1.ModuleDescriptor)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * go_import names the package that should be imported by an app to load the
     * module in the runtime module registry. It is required to make debugging
     * of configuration errors easier for users.
     * </pre>
     *
     * <code>string go_import = 1;</code>
     * @return The goImport.
     */
    java.lang.String getGoImport();
    /**
     * <pre>
     * go_import names the package that should be imported by an app to load the
     * module in the runtime module registry. It is required to make debugging
     * of configuration errors easier for users.
     * </pre>
     *
     * <code>string go_import = 1;</code>
     * @return The bytes for goImport.
     */
    com.google.protobuf.ByteString
        getGoImportBytes();

    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    java.util.List<cosmos.app.v1alpha1.Module.PackageReference> 
        getUsePackageList();
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    cosmos.app.v1alpha1.Module.PackageReference getUsePackage(int index);
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    int getUsePackageCount();
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    java.util.List<? extends cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder> 
        getUsePackageOrBuilderList();
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder getUsePackageOrBuilder(
        int index);

    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    java.util.List<cosmos.app.v1alpha1.Module.MigrateFromInfo> 
        getCanMigrateFromList();
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    cosmos.app.v1alpha1.Module.MigrateFromInfo getCanMigrateFrom(int index);
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    int getCanMigrateFromCount();
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    java.util.List<? extends cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder> 
        getCanMigrateFromOrBuilderList();
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder getCanMigrateFromOrBuilder(
        int index);
  }
  /**
   * <pre>
   * ModuleDescriptor describes an app module.
   * </pre>
   *
   * Protobuf type {@code cosmos.app.v1alpha1.ModuleDescriptor}
   */
  public static final class ModuleDescriptor extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:cosmos.app.v1alpha1.ModuleDescriptor)
      ModuleDescriptorOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ModuleDescriptor.newBuilder() to construct.
    private ModuleDescriptor(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ModuleDescriptor() {
      goImport_ = "";
      usePackage_ = java.util.Collections.emptyList();
      canMigrateFrom_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new ModuleDescriptor();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_ModuleDescriptor_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_ModuleDescriptor_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              cosmos.app.v1alpha1.Module.ModuleDescriptor.class, cosmos.app.v1alpha1.Module.ModuleDescriptor.Builder.class);
    }

    public static final int GO_IMPORT_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object goImport_ = "";
    /**
     * <pre>
     * go_import names the package that should be imported by an app to load the
     * module in the runtime module registry. It is required to make debugging
     * of configuration errors easier for users.
     * </pre>
     *
     * <code>string go_import = 1;</code>
     * @return The goImport.
     */
    @java.lang.Override
    public java.lang.String getGoImport() {
      java.lang.Object ref = goImport_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        goImport_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * go_import names the package that should be imported by an app to load the
     * module in the runtime module registry. It is required to make debugging
     * of configuration errors easier for users.
     * </pre>
     *
     * <code>string go_import = 1;</code>
     * @return The bytes for goImport.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getGoImportBytes() {
      java.lang.Object ref = goImport_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        goImport_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int USE_PACKAGE_FIELD_NUMBER = 2;
    @SuppressWarnings("serial")
    private java.util.List<cosmos.app.v1alpha1.Module.PackageReference> usePackage_;
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    @java.lang.Override
    public java.util.List<cosmos.app.v1alpha1.Module.PackageReference> getUsePackageList() {
      return usePackage_;
    }
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    @java.lang.Override
    public java.util.List<? extends cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder> 
        getUsePackageOrBuilderList() {
      return usePackage_;
    }
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    @java.lang.Override
    public int getUsePackageCount() {
      return usePackage_.size();
    }
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    @java.lang.Override
    public cosmos.app.v1alpha1.Module.PackageReference getUsePackage(int index) {
      return usePackage_.get(index);
    }
    /**
     * <pre>
     * use_package refers to a protobuf package that this module
     * uses and exposes to the world. In an app, only one module should "use"
     * or own a single protobuf package. It is assumed that the module uses
     * all of the .proto files in a single package.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
     */
    @java.lang.Override
    public cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder getUsePackageOrBuilder(
        int index) {
      return usePackage_.get(index);
    }

    public static final int CAN_MIGRATE_FROM_FIELD_NUMBER = 3;
    @SuppressWarnings("serial")
    private java.util.List<cosmos.app.v1alpha1.Module.MigrateFromInfo> canMigrateFrom_;
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    @java.lang.Override
    public java.util.List<cosmos.app.v1alpha1.Module.MigrateFromInfo> getCanMigrateFromList() {
      return canMigrateFrom_;
    }
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    @java.lang.Override
    public java.util.List<? extends cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder> 
        getCanMigrateFromOrBuilderList() {
      return canMigrateFrom_;
    }
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    @java.lang.Override
    public int getCanMigrateFromCount() {
      return canMigrateFrom_.size();
    }
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    @java.lang.Override
    public cosmos.app.v1alpha1.Module.MigrateFromInfo getCanMigrateFrom(int index) {
      return canMigrateFrom_.get(index);
    }
    /**
     * <pre>
     * can_migrate_from defines which module versions this module can migrate
     * state from. The framework will check that one module version is able to
     * migrate from a previous module version before attempting to update its
     * config. It is assumed that modules can transitively migrate from earlier
     * versions. For instance if v3 declares it can migrate from v2, and v2
     * declares it can migrate from v1, the framework knows how to migrate
     * from v1 to v3, assuming all 3 module versions are registered at runtime.
     * </pre>
     *
     * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
     */
    @java.lang.Override
    public cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder getCanMigrateFromOrBuilder(
        int index) {
      return canMigrateFrom_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(goImport_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, goImport_);
      }
      for (int i = 0; i < usePackage_.size(); i++) {
        output.writeMessage(2, usePackage_.get(i));
      }
      for (int i = 0; i < canMigrateFrom_.size(); i++) {
        output.writeMessage(3, canMigrateFrom_.get(i));
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(goImport_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, goImport_);
      }
      for (int i = 0; i < usePackage_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, usePackage_.get(i));
      }
      for (int i = 0; i < canMigrateFrom_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, canMigrateFrom_.get(i));
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof cosmos.app.v1alpha1.Module.ModuleDescriptor)) {
        return super.equals(obj);
      }
      cosmos.app.v1alpha1.Module.ModuleDescriptor other = (cosmos.app.v1alpha1.Module.ModuleDescriptor) obj;

      if (!getGoImport()
          .equals(other.getGoImport())) return false;
      if (!getUsePackageList()
          .equals(other.getUsePackageList())) return false;
      if (!getCanMigrateFromList()
          .equals(other.getCanMigrateFromList())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + GO_IMPORT_FIELD_NUMBER;
      hash = (53 * hash) + getGoImport().hashCode();
      if (getUsePackageCount() > 0) {
        hash = (37 * hash) + USE_PACKAGE_FIELD_NUMBER;
        hash = (53 * hash) + getUsePackageList().hashCode();
      }
      if (getCanMigrateFromCount() > 0) {
        hash = (37 * hash) + CAN_MIGRATE_FROM_FIELD_NUMBER;
        hash = (53 * hash) + getCanMigrateFromList().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.ModuleDescriptor parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cosmos.app.v1alpha1.Module.ModuleDescriptor prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ModuleDescriptor describes an app module.
     * </pre>
     *
     * Protobuf type {@code cosmos.app.v1alpha1.ModuleDescriptor}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:cosmos.app.v1alpha1.ModuleDescriptor)
        cosmos.app.v1alpha1.Module.ModuleDescriptorOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_ModuleDescriptor_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_ModuleDescriptor_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                cosmos.app.v1alpha1.Module.ModuleDescriptor.class, cosmos.app.v1alpha1.Module.ModuleDescriptor.Builder.class);
      }

      // Construct using cosmos.app.v1alpha1.Module.ModuleDescriptor.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        goImport_ = "";
        if (usePackageBuilder_ == null) {
          usePackage_ = java.util.Collections.emptyList();
        } else {
          usePackage_ = null;
          usePackageBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (canMigrateFromBuilder_ == null) {
          canMigrateFrom_ = java.util.Collections.emptyList();
        } else {
          canMigrateFrom_ = null;
          canMigrateFromBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_ModuleDescriptor_descriptor;
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.ModuleDescriptor getDefaultInstanceForType() {
        return cosmos.app.v1alpha1.Module.ModuleDescriptor.getDefaultInstance();
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.ModuleDescriptor build() {
        cosmos.app.v1alpha1.Module.ModuleDescriptor result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.ModuleDescriptor buildPartial() {
        cosmos.app.v1alpha1.Module.ModuleDescriptor result = new cosmos.app.v1alpha1.Module.ModuleDescriptor(this);
        buildPartialRepeatedFields(result);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartialRepeatedFields(cosmos.app.v1alpha1.Module.ModuleDescriptor result) {
        if (usePackageBuilder_ == null) {
          if (((bitField0_ & 0x00000002) != 0)) {
            usePackage_ = java.util.Collections.unmodifiableList(usePackage_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.usePackage_ = usePackage_;
        } else {
          result.usePackage_ = usePackageBuilder_.build();
        }
        if (canMigrateFromBuilder_ == null) {
          if (((bitField0_ & 0x00000004) != 0)) {
            canMigrateFrom_ = java.util.Collections.unmodifiableList(canMigrateFrom_);
            bitField0_ = (bitField0_ & ~0x00000004);
          }
          result.canMigrateFrom_ = canMigrateFrom_;
        } else {
          result.canMigrateFrom_ = canMigrateFromBuilder_.build();
        }
      }

      private void buildPartial0(cosmos.app.v1alpha1.Module.ModuleDescriptor result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.goImport_ = goImport_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof cosmos.app.v1alpha1.Module.ModuleDescriptor) {
          return mergeFrom((cosmos.app.v1alpha1.Module.ModuleDescriptor)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(cosmos.app.v1alpha1.Module.ModuleDescriptor other) {
        if (other == cosmos.app.v1alpha1.Module.ModuleDescriptor.getDefaultInstance()) return this;
        if (!other.getGoImport().isEmpty()) {
          goImport_ = other.goImport_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (usePackageBuilder_ == null) {
          if (!other.usePackage_.isEmpty()) {
            if (usePackage_.isEmpty()) {
              usePackage_ = other.usePackage_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureUsePackageIsMutable();
              usePackage_.addAll(other.usePackage_);
            }
            onChanged();
          }
        } else {
          if (!other.usePackage_.isEmpty()) {
            if (usePackageBuilder_.isEmpty()) {
              usePackageBuilder_.dispose();
              usePackageBuilder_ = null;
              usePackage_ = other.usePackage_;
              bitField0_ = (bitField0_ & ~0x00000002);
              usePackageBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getUsePackageFieldBuilder() : null;
            } else {
              usePackageBuilder_.addAllMessages(other.usePackage_);
            }
          }
        }
        if (canMigrateFromBuilder_ == null) {
          if (!other.canMigrateFrom_.isEmpty()) {
            if (canMigrateFrom_.isEmpty()) {
              canMigrateFrom_ = other.canMigrateFrom_;
              bitField0_ = (bitField0_ & ~0x00000004);
            } else {
              ensureCanMigrateFromIsMutable();
              canMigrateFrom_.addAll(other.canMigrateFrom_);
            }
            onChanged();
          }
        } else {
          if (!other.canMigrateFrom_.isEmpty()) {
            if (canMigrateFromBuilder_.isEmpty()) {
              canMigrateFromBuilder_.dispose();
              canMigrateFromBuilder_ = null;
              canMigrateFrom_ = other.canMigrateFrom_;
              bitField0_ = (bitField0_ & ~0x00000004);
              canMigrateFromBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getCanMigrateFromFieldBuilder() : null;
            } else {
              canMigrateFromBuilder_.addAllMessages(other.canMigrateFrom_);
            }
          }
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                goImport_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 18: {
                cosmos.app.v1alpha1.Module.PackageReference m =
                    input.readMessage(
                        cosmos.app.v1alpha1.Module.PackageReference.parser(),
                        extensionRegistry);
                if (usePackageBuilder_ == null) {
                  ensureUsePackageIsMutable();
                  usePackage_.add(m);
                } else {
                  usePackageBuilder_.addMessage(m);
                }
                break;
              } // case 18
              case 26: {
                cosmos.app.v1alpha1.Module.MigrateFromInfo m =
                    input.readMessage(
                        cosmos.app.v1alpha1.Module.MigrateFromInfo.parser(),
                        extensionRegistry);
                if (canMigrateFromBuilder_ == null) {
                  ensureCanMigrateFromIsMutable();
                  canMigrateFrom_.add(m);
                } else {
                  canMigrateFromBuilder_.addMessage(m);
                }
                break;
              } // case 26
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object goImport_ = "";
      /**
       * <pre>
       * go_import names the package that should be imported by an app to load the
       * module in the runtime module registry. It is required to make debugging
       * of configuration errors easier for users.
       * </pre>
       *
       * <code>string go_import = 1;</code>
       * @return The goImport.
       */
      public java.lang.String getGoImport() {
        java.lang.Object ref = goImport_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          goImport_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * go_import names the package that should be imported by an app to load the
       * module in the runtime module registry. It is required to make debugging
       * of configuration errors easier for users.
       * </pre>
       *
       * <code>string go_import = 1;</code>
       * @return The bytes for goImport.
       */
      public com.google.protobuf.ByteString
          getGoImportBytes() {
        java.lang.Object ref = goImport_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          goImport_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * go_import names the package that should be imported by an app to load the
       * module in the runtime module registry. It is required to make debugging
       * of configuration errors easier for users.
       * </pre>
       *
       * <code>string go_import = 1;</code>
       * @param value The goImport to set.
       * @return This builder for chaining.
       */
      public Builder setGoImport(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        goImport_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * go_import names the package that should be imported by an app to load the
       * module in the runtime module registry. It is required to make debugging
       * of configuration errors easier for users.
       * </pre>
       *
       * <code>string go_import = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearGoImport() {
        goImport_ = getDefaultInstance().getGoImport();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * go_import names the package that should be imported by an app to load the
       * module in the runtime module registry. It is required to make debugging
       * of configuration errors easier for users.
       * </pre>
       *
       * <code>string go_import = 1;</code>
       * @param value The bytes for goImport to set.
       * @return This builder for chaining.
       */
      public Builder setGoImportBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        goImport_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private java.util.List<cosmos.app.v1alpha1.Module.PackageReference> usePackage_ =
        java.util.Collections.emptyList();
      private void ensureUsePackageIsMutable() {
        if (!((bitField0_ & 0x00000002) != 0)) {
          usePackage_ = new java.util.ArrayList<cosmos.app.v1alpha1.Module.PackageReference>(usePackage_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          cosmos.app.v1alpha1.Module.PackageReference, cosmos.app.v1alpha1.Module.PackageReference.Builder, cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder> usePackageBuilder_;

      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public java.util.List<cosmos.app.v1alpha1.Module.PackageReference> getUsePackageList() {
        if (usePackageBuilder_ == null) {
          return java.util.Collections.unmodifiableList(usePackage_);
        } else {
          return usePackageBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public int getUsePackageCount() {
        if (usePackageBuilder_ == null) {
          return usePackage_.size();
        } else {
          return usePackageBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public cosmos.app.v1alpha1.Module.PackageReference getUsePackage(int index) {
        if (usePackageBuilder_ == null) {
          return usePackage_.get(index);
        } else {
          return usePackageBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder setUsePackage(
          int index, cosmos.app.v1alpha1.Module.PackageReference value) {
        if (usePackageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUsePackageIsMutable();
          usePackage_.set(index, value);
          onChanged();
        } else {
          usePackageBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder setUsePackage(
          int index, cosmos.app.v1alpha1.Module.PackageReference.Builder builderForValue) {
        if (usePackageBuilder_ == null) {
          ensureUsePackageIsMutable();
          usePackage_.set(index, builderForValue.build());
          onChanged();
        } else {
          usePackageBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder addUsePackage(cosmos.app.v1alpha1.Module.PackageReference value) {
        if (usePackageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUsePackageIsMutable();
          usePackage_.add(value);
          onChanged();
        } else {
          usePackageBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder addUsePackage(
          int index, cosmos.app.v1alpha1.Module.PackageReference value) {
        if (usePackageBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureUsePackageIsMutable();
          usePackage_.add(index, value);
          onChanged();
        } else {
          usePackageBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder addUsePackage(
          cosmos.app.v1alpha1.Module.PackageReference.Builder builderForValue) {
        if (usePackageBuilder_ == null) {
          ensureUsePackageIsMutable();
          usePackage_.add(builderForValue.build());
          onChanged();
        } else {
          usePackageBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder addUsePackage(
          int index, cosmos.app.v1alpha1.Module.PackageReference.Builder builderForValue) {
        if (usePackageBuilder_ == null) {
          ensureUsePackageIsMutable();
          usePackage_.add(index, builderForValue.build());
          onChanged();
        } else {
          usePackageBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder addAllUsePackage(
          java.lang.Iterable<? extends cosmos.app.v1alpha1.Module.PackageReference> values) {
        if (usePackageBuilder_ == null) {
          ensureUsePackageIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, usePackage_);
          onChanged();
        } else {
          usePackageBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder clearUsePackage() {
        if (usePackageBuilder_ == null) {
          usePackage_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          usePackageBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public Builder removeUsePackage(int index) {
        if (usePackageBuilder_ == null) {
          ensureUsePackageIsMutable();
          usePackage_.remove(index);
          onChanged();
        } else {
          usePackageBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public cosmos.app.v1alpha1.Module.PackageReference.Builder getUsePackageBuilder(
          int index) {
        return getUsePackageFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder getUsePackageOrBuilder(
          int index) {
        if (usePackageBuilder_ == null) {
          return usePackage_.get(index);  } else {
          return usePackageBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public java.util.List<? extends cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder> 
           getUsePackageOrBuilderList() {
        if (usePackageBuilder_ != null) {
          return usePackageBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(usePackage_);
        }
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public cosmos.app.v1alpha1.Module.PackageReference.Builder addUsePackageBuilder() {
        return getUsePackageFieldBuilder().addBuilder(
            cosmos.app.v1alpha1.Module.PackageReference.getDefaultInstance());
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public cosmos.app.v1alpha1.Module.PackageReference.Builder addUsePackageBuilder(
          int index) {
        return getUsePackageFieldBuilder().addBuilder(
            index, cosmos.app.v1alpha1.Module.PackageReference.getDefaultInstance());
      }
      /**
       * <pre>
       * use_package refers to a protobuf package that this module
       * uses and exposes to the world. In an app, only one module should "use"
       * or own a single protobuf package. It is assumed that the module uses
       * all of the .proto files in a single package.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.PackageReference use_package = 2;</code>
       */
      public java.util.List<cosmos.app.v1alpha1.Module.PackageReference.Builder> 
           getUsePackageBuilderList() {
        return getUsePackageFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          cosmos.app.v1alpha1.Module.PackageReference, cosmos.app.v1alpha1.Module.PackageReference.Builder, cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder> 
          getUsePackageFieldBuilder() {
        if (usePackageBuilder_ == null) {
          usePackageBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              cosmos.app.v1alpha1.Module.PackageReference, cosmos.app.v1alpha1.Module.PackageReference.Builder, cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder>(
                  usePackage_,
                  ((bitField0_ & 0x00000002) != 0),
                  getParentForChildren(),
                  isClean());
          usePackage_ = null;
        }
        return usePackageBuilder_;
      }

      private java.util.List<cosmos.app.v1alpha1.Module.MigrateFromInfo> canMigrateFrom_ =
        java.util.Collections.emptyList();
      private void ensureCanMigrateFromIsMutable() {
        if (!((bitField0_ & 0x00000004) != 0)) {
          canMigrateFrom_ = new java.util.ArrayList<cosmos.app.v1alpha1.Module.MigrateFromInfo>(canMigrateFrom_);
          bitField0_ |= 0x00000004;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          cosmos.app.v1alpha1.Module.MigrateFromInfo, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder, cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder> canMigrateFromBuilder_;

      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public java.util.List<cosmos.app.v1alpha1.Module.MigrateFromInfo> getCanMigrateFromList() {
        if (canMigrateFromBuilder_ == null) {
          return java.util.Collections.unmodifiableList(canMigrateFrom_);
        } else {
          return canMigrateFromBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public int getCanMigrateFromCount() {
        if (canMigrateFromBuilder_ == null) {
          return canMigrateFrom_.size();
        } else {
          return canMigrateFromBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public cosmos.app.v1alpha1.Module.MigrateFromInfo getCanMigrateFrom(int index) {
        if (canMigrateFromBuilder_ == null) {
          return canMigrateFrom_.get(index);
        } else {
          return canMigrateFromBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder setCanMigrateFrom(
          int index, cosmos.app.v1alpha1.Module.MigrateFromInfo value) {
        if (canMigrateFromBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.set(index, value);
          onChanged();
        } else {
          canMigrateFromBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder setCanMigrateFrom(
          int index, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder builderForValue) {
        if (canMigrateFromBuilder_ == null) {
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.set(index, builderForValue.build());
          onChanged();
        } else {
          canMigrateFromBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder addCanMigrateFrom(cosmos.app.v1alpha1.Module.MigrateFromInfo value) {
        if (canMigrateFromBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.add(value);
          onChanged();
        } else {
          canMigrateFromBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder addCanMigrateFrom(
          int index, cosmos.app.v1alpha1.Module.MigrateFromInfo value) {
        if (canMigrateFromBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.add(index, value);
          onChanged();
        } else {
          canMigrateFromBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder addCanMigrateFrom(
          cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder builderForValue) {
        if (canMigrateFromBuilder_ == null) {
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.add(builderForValue.build());
          onChanged();
        } else {
          canMigrateFromBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder addCanMigrateFrom(
          int index, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder builderForValue) {
        if (canMigrateFromBuilder_ == null) {
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.add(index, builderForValue.build());
          onChanged();
        } else {
          canMigrateFromBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder addAllCanMigrateFrom(
          java.lang.Iterable<? extends cosmos.app.v1alpha1.Module.MigrateFromInfo> values) {
        if (canMigrateFromBuilder_ == null) {
          ensureCanMigrateFromIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, canMigrateFrom_);
          onChanged();
        } else {
          canMigrateFromBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder clearCanMigrateFrom() {
        if (canMigrateFromBuilder_ == null) {
          canMigrateFrom_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000004);
          onChanged();
        } else {
          canMigrateFromBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public Builder removeCanMigrateFrom(int index) {
        if (canMigrateFromBuilder_ == null) {
          ensureCanMigrateFromIsMutable();
          canMigrateFrom_.remove(index);
          onChanged();
        } else {
          canMigrateFromBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder getCanMigrateFromBuilder(
          int index) {
        return getCanMigrateFromFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder getCanMigrateFromOrBuilder(
          int index) {
        if (canMigrateFromBuilder_ == null) {
          return canMigrateFrom_.get(index);  } else {
          return canMigrateFromBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public java.util.List<? extends cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder> 
           getCanMigrateFromOrBuilderList() {
        if (canMigrateFromBuilder_ != null) {
          return canMigrateFromBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(canMigrateFrom_);
        }
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder addCanMigrateFromBuilder() {
        return getCanMigrateFromFieldBuilder().addBuilder(
            cosmos.app.v1alpha1.Module.MigrateFromInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder addCanMigrateFromBuilder(
          int index) {
        return getCanMigrateFromFieldBuilder().addBuilder(
            index, cosmos.app.v1alpha1.Module.MigrateFromInfo.getDefaultInstance());
      }
      /**
       * <pre>
       * can_migrate_from defines which module versions this module can migrate
       * state from. The framework will check that one module version is able to
       * migrate from a previous module version before attempting to update its
       * config. It is assumed that modules can transitively migrate from earlier
       * versions. For instance if v3 declares it can migrate from v2, and v2
       * declares it can migrate from v1, the framework knows how to migrate
       * from v1 to v3, assuming all 3 module versions are registered at runtime.
       * </pre>
       *
       * <code>repeated .cosmos.app.v1alpha1.MigrateFromInfo can_migrate_from = 3;</code>
       */
      public java.util.List<cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder> 
           getCanMigrateFromBuilderList() {
        return getCanMigrateFromFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          cosmos.app.v1alpha1.Module.MigrateFromInfo, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder, cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder> 
          getCanMigrateFromFieldBuilder() {
        if (canMigrateFromBuilder_ == null) {
          canMigrateFromBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              cosmos.app.v1alpha1.Module.MigrateFromInfo, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder, cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder>(
                  canMigrateFrom_,
                  ((bitField0_ & 0x00000004) != 0),
                  getParentForChildren(),
                  isClean());
          canMigrateFrom_ = null;
        }
        return canMigrateFromBuilder_;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:cosmos.app.v1alpha1.ModuleDescriptor)
    }

    // @@protoc_insertion_point(class_scope:cosmos.app.v1alpha1.ModuleDescriptor)
    private static final cosmos.app.v1alpha1.Module.ModuleDescriptor DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new cosmos.app.v1alpha1.Module.ModuleDescriptor();
    }

    public static cosmos.app.v1alpha1.Module.ModuleDescriptor getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ModuleDescriptor>
        PARSER = new com.google.protobuf.AbstractParser<ModuleDescriptor>() {
      @java.lang.Override
      public ModuleDescriptor parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<ModuleDescriptor> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<ModuleDescriptor> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public cosmos.app.v1alpha1.Module.ModuleDescriptor getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface PackageReferenceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cosmos.app.v1alpha1.PackageReference)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * name is the fully-qualified name of the package.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * name is the fully-qualified name of the package.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * revision is the optional revision of the package that is being used.
     * Protobuf packages used in Cosmos should generally have a major version
     * as the last part of the package name, ex. foo.bar.baz.v1.
     * The revision of a package can be thought of as the minor version of a
     * package which has additional backwards compatible definitions that weren't
     * present in a previous version.
     *
     * A package should indicate its revision with a source code comment
     * above the package declaration in one of its files containing the
     * text "Revision N" where N is an integer revision. All packages start
     * at revision 0 the first time they are released in a module.
     *
     * When a new version of a module is released and items are added to existing
     * .proto files, these definitions should contain comments of the form
     * "Since Revision N" where N is an integer revision.
     *
     * When the module runtime starts up, it will check the pinned proto
     * image and panic if there are runtime protobuf definitions that are not
     * in the pinned descriptor which do not have
     * a "Since Revision N" comment or have a "Since Revision N" comment where
     * N is &lt;= to the revision specified here. This indicates that the protobuf
     * files have been updated, but the pinned file descriptor hasn't.
     *
     * If there are items in the pinned file descriptor with a revision
     * greater than the value indicated here, this will also cause a panic
     * as it may mean that the pinned descriptor for a legacy module has been
     * improperly updated or that there is some other versioning discrepancy.
     * Runtime protobuf definitions will also be checked for compatibility
     * with pinned file descriptors to make sure there are no incompatible changes.
     *
     * This behavior ensures that:
     * * pinned proto images are up-to-date
     * * protobuf files are carefully annotated with revision comments which
     *   are important good client UX
     * * protobuf files are changed in backwards and forwards compatible ways
     * </pre>
     *
     * <code>uint32 revision = 2;</code>
     * @return The revision.
     */
    int getRevision();
  }
  /**
   * <pre>
   * PackageReference is a reference to a protobuf package used by a module.
   * </pre>
   *
   * Protobuf type {@code cosmos.app.v1alpha1.PackageReference}
   */
  public static final class PackageReference extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:cosmos.app.v1alpha1.PackageReference)
      PackageReferenceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use PackageReference.newBuilder() to construct.
    private PackageReference(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private PackageReference() {
      name_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new PackageReference();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_PackageReference_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_PackageReference_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              cosmos.app.v1alpha1.Module.PackageReference.class, cosmos.app.v1alpha1.Module.PackageReference.Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * name is the fully-qualified name of the package.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * name is the fully-qualified name of the package.
     * </pre>
     *
     * <code>string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int REVISION_FIELD_NUMBER = 2;
    private int revision_ = 0;
    /**
     * <pre>
     * revision is the optional revision of the package that is being used.
     * Protobuf packages used in Cosmos should generally have a major version
     * as the last part of the package name, ex. foo.bar.baz.v1.
     * The revision of a package can be thought of as the minor version of a
     * package which has additional backwards compatible definitions that weren't
     * present in a previous version.
     *
     * A package should indicate its revision with a source code comment
     * above the package declaration in one of its files containing the
     * text "Revision N" where N is an integer revision. All packages start
     * at revision 0 the first time they are released in a module.
     *
     * When a new version of a module is released and items are added to existing
     * .proto files, these definitions should contain comments of the form
     * "Since Revision N" where N is an integer revision.
     *
     * When the module runtime starts up, it will check the pinned proto
     * image and panic if there are runtime protobuf definitions that are not
     * in the pinned descriptor which do not have
     * a "Since Revision N" comment or have a "Since Revision N" comment where
     * N is &lt;= to the revision specified here. This indicates that the protobuf
     * files have been updated, but the pinned file descriptor hasn't.
     *
     * If there are items in the pinned file descriptor with a revision
     * greater than the value indicated here, this will also cause a panic
     * as it may mean that the pinned descriptor for a legacy module has been
     * improperly updated or that there is some other versioning discrepancy.
     * Runtime protobuf definitions will also be checked for compatibility
     * with pinned file descriptors to make sure there are no incompatible changes.
     *
     * This behavior ensures that:
     * * pinned proto images are up-to-date
     * * protobuf files are carefully annotated with revision comments which
     *   are important good client UX
     * * protobuf files are changed in backwards and forwards compatible ways
     * </pre>
     *
     * <code>uint32 revision = 2;</code>
     * @return The revision.
     */
    @java.lang.Override
    public int getRevision() {
      return revision_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (revision_ != 0) {
        output.writeUInt32(2, revision_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(name_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (revision_ != 0) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, revision_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof cosmos.app.v1alpha1.Module.PackageReference)) {
        return super.equals(obj);
      }
      cosmos.app.v1alpha1.Module.PackageReference other = (cosmos.app.v1alpha1.Module.PackageReference) obj;

      if (!getName()
          .equals(other.getName())) return false;
      if (getRevision()
          != other.getRevision()) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + REVISION_FIELD_NUMBER;
      hash = (53 * hash) + getRevision();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.PackageReference parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cosmos.app.v1alpha1.Module.PackageReference prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * PackageReference is a reference to a protobuf package used by a module.
     * </pre>
     *
     * Protobuf type {@code cosmos.app.v1alpha1.PackageReference}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:cosmos.app.v1alpha1.PackageReference)
        cosmos.app.v1alpha1.Module.PackageReferenceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_PackageReference_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_PackageReference_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                cosmos.app.v1alpha1.Module.PackageReference.class, cosmos.app.v1alpha1.Module.PackageReference.Builder.class);
      }

      // Construct using cosmos.app.v1alpha1.Module.PackageReference.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        revision_ = 0;
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_PackageReference_descriptor;
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.PackageReference getDefaultInstanceForType() {
        return cosmos.app.v1alpha1.Module.PackageReference.getDefaultInstance();
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.PackageReference build() {
        cosmos.app.v1alpha1.Module.PackageReference result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.PackageReference buildPartial() {
        cosmos.app.v1alpha1.Module.PackageReference result = new cosmos.app.v1alpha1.Module.PackageReference(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(cosmos.app.v1alpha1.Module.PackageReference result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.revision_ = revision_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof cosmos.app.v1alpha1.Module.PackageReference) {
          return mergeFrom((cosmos.app.v1alpha1.Module.PackageReference)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(cosmos.app.v1alpha1.Module.PackageReference other) {
        if (other == cosmos.app.v1alpha1.Module.PackageReference.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.getRevision() != 0) {
          setRevision(other.getRevision());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                revision_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * name is the fully-qualified name of the package.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * name is the fully-qualified name of the package.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * name is the fully-qualified name of the package.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the fully-qualified name of the package.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * name is the fully-qualified name of the package.
       * </pre>
       *
       * <code>string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private int revision_ ;
      /**
       * <pre>
       * revision is the optional revision of the package that is being used.
       * Protobuf packages used in Cosmos should generally have a major version
       * as the last part of the package name, ex. foo.bar.baz.v1.
       * The revision of a package can be thought of as the minor version of a
       * package which has additional backwards compatible definitions that weren't
       * present in a previous version.
       *
       * A package should indicate its revision with a source code comment
       * above the package declaration in one of its files containing the
       * text "Revision N" where N is an integer revision. All packages start
       * at revision 0 the first time they are released in a module.
       *
       * When a new version of a module is released and items are added to existing
       * .proto files, these definitions should contain comments of the form
       * "Since Revision N" where N is an integer revision.
       *
       * When the module runtime starts up, it will check the pinned proto
       * image and panic if there are runtime protobuf definitions that are not
       * in the pinned descriptor which do not have
       * a "Since Revision N" comment or have a "Since Revision N" comment where
       * N is &lt;= to the revision specified here. This indicates that the protobuf
       * files have been updated, but the pinned file descriptor hasn't.
       *
       * If there are items in the pinned file descriptor with a revision
       * greater than the value indicated here, this will also cause a panic
       * as it may mean that the pinned descriptor for a legacy module has been
       * improperly updated or that there is some other versioning discrepancy.
       * Runtime protobuf definitions will also be checked for compatibility
       * with pinned file descriptors to make sure there are no incompatible changes.
       *
       * This behavior ensures that:
       * * pinned proto images are up-to-date
       * * protobuf files are carefully annotated with revision comments which
       *   are important good client UX
       * * protobuf files are changed in backwards and forwards compatible ways
       * </pre>
       *
       * <code>uint32 revision = 2;</code>
       * @return The revision.
       */
      @java.lang.Override
      public int getRevision() {
        return revision_;
      }
      /**
       * <pre>
       * revision is the optional revision of the package that is being used.
       * Protobuf packages used in Cosmos should generally have a major version
       * as the last part of the package name, ex. foo.bar.baz.v1.
       * The revision of a package can be thought of as the minor version of a
       * package which has additional backwards compatible definitions that weren't
       * present in a previous version.
       *
       * A package should indicate its revision with a source code comment
       * above the package declaration in one of its files containing the
       * text "Revision N" where N is an integer revision. All packages start
       * at revision 0 the first time they are released in a module.
       *
       * When a new version of a module is released and items are added to existing
       * .proto files, these definitions should contain comments of the form
       * "Since Revision N" where N is an integer revision.
       *
       * When the module runtime starts up, it will check the pinned proto
       * image and panic if there are runtime protobuf definitions that are not
       * in the pinned descriptor which do not have
       * a "Since Revision N" comment or have a "Since Revision N" comment where
       * N is &lt;= to the revision specified here. This indicates that the protobuf
       * files have been updated, but the pinned file descriptor hasn't.
       *
       * If there are items in the pinned file descriptor with a revision
       * greater than the value indicated here, this will also cause a panic
       * as it may mean that the pinned descriptor for a legacy module has been
       * improperly updated or that there is some other versioning discrepancy.
       * Runtime protobuf definitions will also be checked for compatibility
       * with pinned file descriptors to make sure there are no incompatible changes.
       *
       * This behavior ensures that:
       * * pinned proto images are up-to-date
       * * protobuf files are carefully annotated with revision comments which
       *   are important good client UX
       * * protobuf files are changed in backwards and forwards compatible ways
       * </pre>
       *
       * <code>uint32 revision = 2;</code>
       * @param value The revision to set.
       * @return This builder for chaining.
       */
      public Builder setRevision(int value) {

        revision_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * revision is the optional revision of the package that is being used.
       * Protobuf packages used in Cosmos should generally have a major version
       * as the last part of the package name, ex. foo.bar.baz.v1.
       * The revision of a package can be thought of as the minor version of a
       * package which has additional backwards compatible definitions that weren't
       * present in a previous version.
       *
       * A package should indicate its revision with a source code comment
       * above the package declaration in one of its files containing the
       * text "Revision N" where N is an integer revision. All packages start
       * at revision 0 the first time they are released in a module.
       *
       * When a new version of a module is released and items are added to existing
       * .proto files, these definitions should contain comments of the form
       * "Since Revision N" where N is an integer revision.
       *
       * When the module runtime starts up, it will check the pinned proto
       * image and panic if there are runtime protobuf definitions that are not
       * in the pinned descriptor which do not have
       * a "Since Revision N" comment or have a "Since Revision N" comment where
       * N is &lt;= to the revision specified here. This indicates that the protobuf
       * files have been updated, but the pinned file descriptor hasn't.
       *
       * If there are items in the pinned file descriptor with a revision
       * greater than the value indicated here, this will also cause a panic
       * as it may mean that the pinned descriptor for a legacy module has been
       * improperly updated or that there is some other versioning discrepancy.
       * Runtime protobuf definitions will also be checked for compatibility
       * with pinned file descriptors to make sure there are no incompatible changes.
       *
       * This behavior ensures that:
       * * pinned proto images are up-to-date
       * * protobuf files are carefully annotated with revision comments which
       *   are important good client UX
       * * protobuf files are changed in backwards and forwards compatible ways
       * </pre>
       *
       * <code>uint32 revision = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearRevision() {
        bitField0_ = (bitField0_ & ~0x00000002);
        revision_ = 0;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:cosmos.app.v1alpha1.PackageReference)
    }

    // @@protoc_insertion_point(class_scope:cosmos.app.v1alpha1.PackageReference)
    private static final cosmos.app.v1alpha1.Module.PackageReference DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new cosmos.app.v1alpha1.Module.PackageReference();
    }

    public static cosmos.app.v1alpha1.Module.PackageReference getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<PackageReference>
        PARSER = new com.google.protobuf.AbstractParser<PackageReference>() {
      @java.lang.Override
      public PackageReference parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<PackageReference> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<PackageReference> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public cosmos.app.v1alpha1.Module.PackageReference getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface MigrateFromInfoOrBuilder extends
      // @@protoc_insertion_point(interface_extends:cosmos.app.v1alpha1.MigrateFromInfo)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * module is the fully-qualified protobuf name of the module config object
     * for the previous module version, ex: "cosmos.group.module.v1.Module".
     * </pre>
     *
     * <code>string module = 1;</code>
     * @return The module.
     */
    java.lang.String getModule();
    /**
     * <pre>
     * module is the fully-qualified protobuf name of the module config object
     * for the previous module version, ex: "cosmos.group.module.v1.Module".
     * </pre>
     *
     * <code>string module = 1;</code>
     * @return The bytes for module.
     */
    com.google.protobuf.ByteString
        getModuleBytes();
  }
  /**
   * <pre>
   * MigrateFromInfo is information on a module version that a newer module
   * can migrate from.
   * </pre>
   *
   * Protobuf type {@code cosmos.app.v1alpha1.MigrateFromInfo}
   */
  public static final class MigrateFromInfo extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:cosmos.app.v1alpha1.MigrateFromInfo)
      MigrateFromInfoOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use MigrateFromInfo.newBuilder() to construct.
    private MigrateFromInfo(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private MigrateFromInfo() {
      module_ = "";
    }

    @java.lang.Override
    @SuppressWarnings({"unused"})
    protected java.lang.Object newInstance(
        UnusedPrivateParameter unused) {
      return new MigrateFromInfo();
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_MigrateFromInfo_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_MigrateFromInfo_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              cosmos.app.v1alpha1.Module.MigrateFromInfo.class, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder.class);
    }

    public static final int MODULE_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object module_ = "";
    /**
     * <pre>
     * module is the fully-qualified protobuf name of the module config object
     * for the previous module version, ex: "cosmos.group.module.v1.Module".
     * </pre>
     *
     * <code>string module = 1;</code>
     * @return The module.
     */
    @java.lang.Override
    public java.lang.String getModule() {
      java.lang.Object ref = module_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        module_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * module is the fully-qualified protobuf name of the module config object
     * for the previous module version, ex: "cosmos.group.module.v1.Module".
     * </pre>
     *
     * <code>string module = 1;</code>
     * @return The bytes for module.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getModuleBytes() {
      java.lang.Object ref = module_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        module_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(module_)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, module_);
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!com.google.protobuf.GeneratedMessageV3.isStringEmpty(module_)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, module_);
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof cosmos.app.v1alpha1.Module.MigrateFromInfo)) {
        return super.equals(obj);
      }
      cosmos.app.v1alpha1.Module.MigrateFromInfo other = (cosmos.app.v1alpha1.Module.MigrateFromInfo) obj;

      if (!getModule()
          .equals(other.getModule())) return false;
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + MODULE_FIELD_NUMBER;
      hash = (53 * hash) + getModule().hashCode();
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static cosmos.app.v1alpha1.Module.MigrateFromInfo parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(cosmos.app.v1alpha1.Module.MigrateFromInfo prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * MigrateFromInfo is information on a module version that a newer module
     * can migrate from.
     * </pre>
     *
     * Protobuf type {@code cosmos.app.v1alpha1.MigrateFromInfo}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:cosmos.app.v1alpha1.MigrateFromInfo)
        cosmos.app.v1alpha1.Module.MigrateFromInfoOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_MigrateFromInfo_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_MigrateFromInfo_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                cosmos.app.v1alpha1.Module.MigrateFromInfo.class, cosmos.app.v1alpha1.Module.MigrateFromInfo.Builder.class);
      }

      // Construct using cosmos.app.v1alpha1.Module.MigrateFromInfo.newBuilder()
      private Builder() {

      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);

      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        module_ = "";
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return cosmos.app.v1alpha1.Module.internal_static_cosmos_app_v1alpha1_MigrateFromInfo_descriptor;
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.MigrateFromInfo getDefaultInstanceForType() {
        return cosmos.app.v1alpha1.Module.MigrateFromInfo.getDefaultInstance();
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.MigrateFromInfo build() {
        cosmos.app.v1alpha1.Module.MigrateFromInfo result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public cosmos.app.v1alpha1.Module.MigrateFromInfo buildPartial() {
        cosmos.app.v1alpha1.Module.MigrateFromInfo result = new cosmos.app.v1alpha1.Module.MigrateFromInfo(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(cosmos.app.v1alpha1.Module.MigrateFromInfo result) {
        int from_bitField0_ = bitField0_;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.module_ = module_;
        }
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof cosmos.app.v1alpha1.Module.MigrateFromInfo) {
          return mergeFrom((cosmos.app.v1alpha1.Module.MigrateFromInfo)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(cosmos.app.v1alpha1.Module.MigrateFromInfo other) {
        if (other == cosmos.app.v1alpha1.Module.MigrateFromInfo.getDefaultInstance()) return this;
        if (!other.getModule().isEmpty()) {
          module_ = other.module_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                module_ = input.readStringRequireUtf8();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object module_ = "";
      /**
       * <pre>
       * module is the fully-qualified protobuf name of the module config object
       * for the previous module version, ex: "cosmos.group.module.v1.Module".
       * </pre>
       *
       * <code>string module = 1;</code>
       * @return The module.
       */
      public java.lang.String getModule() {
        java.lang.Object ref = module_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          module_ = s;
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * module is the fully-qualified protobuf name of the module config object
       * for the previous module version, ex: "cosmos.group.module.v1.Module".
       * </pre>
       *
       * <code>string module = 1;</code>
       * @return The bytes for module.
       */
      public com.google.protobuf.ByteString
          getModuleBytes() {
        java.lang.Object ref = module_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          module_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * module is the fully-qualified protobuf name of the module config object
       * for the previous module version, ex: "cosmos.group.module.v1.Module".
       * </pre>
       *
       * <code>string module = 1;</code>
       * @param value The module to set.
       * @return This builder for chaining.
       */
      public Builder setModule(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        module_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * module is the fully-qualified protobuf name of the module config object
       * for the previous module version, ex: "cosmos.group.module.v1.Module".
       * </pre>
       *
       * <code>string module = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearModule() {
        module_ = getDefaultInstance().getModule();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * module is the fully-qualified protobuf name of the module config object
       * for the previous module version, ex: "cosmos.group.module.v1.Module".
       * </pre>
       *
       * <code>string module = 1;</code>
       * @param value The bytes for module to set.
       * @return This builder for chaining.
       */
      public Builder setModuleBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        checkByteStringIsUtf8(value);
        module_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      @java.lang.Override
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      @java.lang.Override
      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:cosmos.app.v1alpha1.MigrateFromInfo)
    }

    // @@protoc_insertion_point(class_scope:cosmos.app.v1alpha1.MigrateFromInfo)
    private static final cosmos.app.v1alpha1.Module.MigrateFromInfo DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new cosmos.app.v1alpha1.Module.MigrateFromInfo();
    }

    public static cosmos.app.v1alpha1.Module.MigrateFromInfo getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<MigrateFromInfo>
        PARSER = new com.google.protobuf.AbstractParser<MigrateFromInfo>() {
      @java.lang.Override
      public MigrateFromInfo parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<MigrateFromInfo> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<MigrateFromInfo> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public cosmos.app.v1alpha1.Module.MigrateFromInfo getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public static final int MODULE_FIELD_NUMBER = 57193479;
  /**
   * <pre>
   * module indicates that this proto type is a config object for an app module
   * and optionally provides other descriptive information about the module.
   * It is recommended that a new module config object and go module is versioned
   * for every state machine breaking version of a module. The recommended
   * pattern for doing this is to put module config objects in a separate proto
   * package from the API they expose. Ex: the cosmos.group.v1 API would be
   * exposed by module configs cosmos.group.module.v1, cosmos.group.module.v2, etc.
   * </pre>
   *
   * <code>extend .google.protobuf.MessageOptions { ... }</code>
   */
  public static final
    com.google.protobuf.GeneratedMessage.GeneratedExtension<
      com.google.protobuf.DescriptorProtos.MessageOptions,
      cosmos.app.v1alpha1.Module.ModuleDescriptor> module = com.google.protobuf.GeneratedMessage
          .newFileScopedGeneratedExtension(
        cosmos.app.v1alpha1.Module.ModuleDescriptor.class,
        cosmos.app.v1alpha1.Module.ModuleDescriptor.getDefaultInstance());
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_cosmos_app_v1alpha1_ModuleDescriptor_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_cosmos_app_v1alpha1_ModuleDescriptor_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_cosmos_app_v1alpha1_PackageReference_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_cosmos_app_v1alpha1_PackageReference_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_cosmos_app_v1alpha1_MigrateFromInfo_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_cosmos_app_v1alpha1_MigrateFromInfo_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n cosmos/app/v1alpha1/module.proto\022\023cosm" +
      "os.app.v1alpha1\032 google/protobuf/descrip" +
      "tor.proto\"\241\001\n\020ModuleDescriptor\022\021\n\tgo_imp" +
      "ort\030\001 \001(\t\022:\n\013use_package\030\002 \003(\0132%.cosmos." +
      "app.v1alpha1.PackageReference\022>\n\020can_mig" +
      "rate_from\030\003 \003(\0132$.cosmos.app.v1alpha1.Mi" +
      "grateFromInfo\"2\n\020PackageReference\022\014\n\004nam" +
      "e\030\001 \001(\t\022\020\n\010revision\030\002 \001(\r\"!\n\017MigrateFrom" +
      "Info\022\016\n\006module\030\001 \001(\t:Y\n\006module\022\037.google." +
      "protobuf.MessageOptions\030\207\350\242\033 \001(\0132%.cosmo" +
      "s.app.v1alpha1.ModuleDescriptorb\006proto3"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          com.google.protobuf.DescriptorProtos.getDescriptor(),
        });
    internal_static_cosmos_app_v1alpha1_ModuleDescriptor_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_cosmos_app_v1alpha1_ModuleDescriptor_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_cosmos_app_v1alpha1_ModuleDescriptor_descriptor,
        new java.lang.String[] { "GoImport", "UsePackage", "CanMigrateFrom", });
    internal_static_cosmos_app_v1alpha1_PackageReference_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_cosmos_app_v1alpha1_PackageReference_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_cosmos_app_v1alpha1_PackageReference_descriptor,
        new java.lang.String[] { "Name", "Revision", });
    internal_static_cosmos_app_v1alpha1_MigrateFromInfo_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_cosmos_app_v1alpha1_MigrateFromInfo_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_cosmos_app_v1alpha1_MigrateFromInfo_descriptor,
        new java.lang.String[] { "Module", });
    module.internalInit(descriptor.getExtensions().get(0));
    com.google.protobuf.DescriptorProtos.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
